# vecr

A fast, lightweight C++ math and geometry library for game development and robotics with Python bindings.

I started this project as 1) Python libraries I've found were rudimentary at best, 2) Numpy, of course, is awesome, but is not easy to use in this scenario.

Most of the code was taken from old (15 years+!) pet project https://github.com/mnvl/scratch, the bindings and the documentation were mostly generated by Claude with my curation.

## Features

### Core Math Types
- **Vectors**: Template vector classes (`vec2`, `vec3`, `vec4`) with float and double precision
- **Matrices**: 3x3 and 4x4 matrices with transformation operations (translation, rotation, scaling, perspective)
- **Quaternions**: Full quaternion support with SLERP interpolation
- **Flexible component access**: Use `.x/.y/.z/.w` or `.r/.g/.b/.a` notation

### Geometric Primitives
- Rays and line segments
- 3D planes with intersection tests
- Triangles with barycentric coordinates
- Spheres and capsules
- Axis-aligned bounding boxes (AABB)
- Oriented bounding boxes (OBB)
- View frustums for culling

### Advanced Features
- **Collision detection**: Template-based collision functions between various shapes
- **A* pathfinding**: Grid-based pathfinding with custom scoring
- **Heightfield**: Terrain heightfield with ray tracing
- **Bresenham algorithm**: Line rasterization

### Python Bindings
- Full Python API via nanobind
- NumPy integration for seamless array conversions
- Float and double precision support

## Build Instructions

### Requirements
- CMake 3.10+
- C++11 or later
- Boost (headers + unit_test_framework for tests)
- Python 3.8+ (optional, for Python bindings)
- NumPy (optional, for NumPy integration)

### Building

```bash
# Clone the repository
git clone https://github.com/mnvl/vek.git
cd vek

# Create build directory
mkdir build
cd build

# Configure with CMake
cmake ..

# Build
make

# Run C++ tests
ctest
# or
./vek_tests
```

### Build Options

```bash
# Build without tests
cmake -DVEK_BUILD_TESTS=OFF ..

# Build with Python bindings
cmake -DVEK_BUILD_PYTHON=ON ..

# Both options
cmake -DVEK_BUILD_TESTS=OFF -DVEK_BUILD_PYTHON=ON ..
```

## C++ Usage

```cpp
#include "vec.h"
#include "matrix.h"
#include "quaternion.h"

using namespace vek;

// Vectors
vec3 position(1.0f, 2.0f, 3.0f);
vec3 direction(0.0f, 1.0f, 0.0f);
direction.normalize();

// Dot and cross products
float dot = dot_product(position, direction);
vec3 cross;
cross_product(cross, position, direction);

// Matrices
matrix<4, 4, float> transform;
transform.identity();
transform.translate(1.0f, 2.0f, 3.0f);
transform.rotate(vec3(0.0f, 1.0f, 0.0f), PI / 4.0f);

// Quaternions
quaternion<float> q1, q2;
q1.identity();
q2 = quaternion<float>(0.0f, 0.707f, 0.0f, 0.707f);

// SLERP interpolation
quaternion_slerper<float> slerper;
slerper.setup(q1, q2);
auto q_mid = slerper.interpolate(0.5f);

// Collision detection
sphere<3, float> s1(vec3(0, 0, 0), 1.0f);
sphere<3, float> s2(vec3(1.5f, 0, 0), 1.0f);
contact_info<3, float> contact;
bool colliding = collide(contact, s1, s2);
```

## Python Usage

```python
import pyvek
import numpy as np

# Vectors
v1 = pyvek.vec3(1.0, 2.0, 3.0)
v2 = pyvek.vec3(4.0, 5.0, 6.0)

# Vector operations
dot = pyvek.dot(v1, v2)
cross = pyvek.cross(v1, v2)
normalized = pyvek.normalize(v1)

# Matrices
m = pyvek.mat4()
m.identity()
m.translate(1.0, 2.0, 3.0)
m.rotate(pyvek.vec3(0.0, 1.0, 0.0), 3.14159 / 4.0)

# Transform vectors
v_transformed = m * v1

# Quaternions
q = pyvek.quat(0.0, 0.0, 0.0, 1.0)
q.normalize()

# SLERP
q1 = pyvek.quat(0.0, 0.0, 0.0, 1.0)
q2 = pyvek.quat(0.0, 0.707, 0.0, 0.707)
q_mid = pyvek.slerp(q1, q2, 0.5)

# NumPy integration
arr = np.array([1.0, 2.0, 3.0], dtype=np.float32)
v = pyvek.vec3.from_numpy(arr)
arr_back = v.to_numpy()

# Matrix from NumPy
mat_array = np.eye(4, dtype=np.float32)
mat = pyvek.mat4.from_numpy(mat_array)
mat_back = mat.to_numpy()

# Double precision types
dv = pyvek.dvec3(1.0, 2.0, 3.0)
dm = pyvek.dmat4()
dq = pyvek.dquat(0.0, 0.0, 0.0, 1.0)
```

## Running Python Tests

```bash
# From the build directory
python3 ../src/test_pyvek.py
```

## Architecture

All code lives in `src/` under the `vek` namespace.

### Conventions
- Templates use `scalar_t` typedef for the numeric type
- N-dimensional templates use `ARITY` constant
- Vectors use packed structs with unions for flexible component access
- Matrices use column-major storage (OpenGL style)
- Collision functions return bool and populate output parameters by reference

## API Reference

### Vector Operations
- `length()`, `length_sq()` - Vector magnitude
- `normalize()` - Normalize in place
- `dot_product()` - Dot product
- `cross_product()` - Cross product (3D only)
- `is_collinear()` - Check if vectors are collinear

### Matrix Operations
- `identity()`, `zero()` - Initialize matrices
- `translation()`, `translate()` - Translation transforms
- `rotation()`, `rotate()` - Rotation transforms
- `scaling()`, `scale()` - Scaling transforms
- `perspective()` - Perspective projection
- `lookat()` - Camera view matrix
- `inverse()`, `transpose()` - Matrix operations
- `determinant()`, `trace()` - Matrix properties

### Quaternion Operations
- `identity()` - Set to identity quaternion
- `norm()`, `normalize()` - Quaternion normalization
- `dot_product()` - Quaternion dot product
- SLERP interpolation via `quaternion_slerper`

## Type Aliases

### C++
```cpp
using vec2 = vec<2, float>;
using vec3 = vec<3, float>;
using vec4 = vec<4, float>;
using mat3 = matrix<3, 3, float>;
using mat4 = matrix<4, 4, float>;
using quat = quaternion<float>;
```

### Python
- Float precision: `vec2`, `vec3`, `vec4`, `mat3`, `mat4`, `quat`
- Double precision: `dvec2`, `dvec3`, `dvec4`, `dmat3`, `dmat4`, `dquat`

## License

See LICENSE file for details.

## Contributing

Contributions are welcome! Please ensure all tests pass before submitting pull requests.

```bash
# Run C++ tests
cd build
ctest

# Run Python tests
python3 ../src/test_pyvek.py
```
