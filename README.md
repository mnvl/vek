# rove

A fast, lightweight C++ math and geometry library for robotics and game development with Python bindings.

I started this project as 1) Python libraries I've found were rudimentary at best, 2) Numpy, of course, is awesome, but is not easy to use in this scenario.

Most of the code was taken from old (15 years+!) pet project https://github.com/mnvl/scratch, the bindings and the documentation were mostly generated by Claude with my curation.

## Features

### Core Math Types
- **Vectors**: Template vector classes (`vec2`, `vec3`, `vec4`) with float and double precision
- **Matrices**: 3x3 and 4x4 matrices with transformation operations (translation, rotation, scaling, perspective)
- **Quaternions**: Full quaternion support with SLERP interpolation
- **Flexible component access**: Use `.x/.y/.z/.w` or `.r/.g/.b/.a` notation

### Geometric Primitives
- **Rays**: Half-infinite lines for ray casting and tracing (2D and 3D)
- **Line segments**: Finite lines with distance queries (2D and 3D)
- **Planes**: Infinite planes with intersection and classification tests (3D)
- **Triangles**: Full geometric properties including centers, circles, and ray intersection (3D)
- **Capsules**: Swept spheres for collision detection (2D and 3D)
- **Spheres**: Basic sphere primitives (2D and 3D)
- **AABB**: Axis-aligned bounding boxes (2D and 3D)
- **OBB**: Oriented bounding boxes (2D and 3D)
- **Frustums**: View frustums for camera culling (3D)

### Advanced Features
- **Collision detection**: Template-based collision functions between various shapes
- **A* pathfinding**: Grid-based pathfinding with custom scoring
- **Heightfield**: Terrain heightfield with ray tracing
- **Bresenham algorithm**: Line rasterization

### Python Bindings
- Full Python API via nanobind
- NumPy integration for seamless array conversions
- Float and double precision support

## Build Instructions

### Requirements
- CMake 3.10+
- C++11 or later
- Boost (headers + unit_test_framework for tests)
- Python 3.8+ (optional, for Python bindings)
- NumPy (optional, for NumPy integration)

### Building

```bash
# Clone the repository
git clone https://github.com/mnvl/rove.git
cd rove

# Create build directory
mkdir build
cd build

# Configure with CMake
cmake ..

# Build
make

# Run C++ tests
ctest
# or
./rove_tests
```

### Build Options

```bash
# Build without tests
cmake -DROVE_BUILD_TESTS=OFF ..

# Build with Python bindings
cmake -DROVE_BUILD_PYTHON=ON ..

# Both options
cmake -DROVE_BUILD_TESTS=OFF -DVEK_BUILD_PYTHON=ON ..
```

## C++ Usage

```cpp
#include "vec.h"
#include "matrix.h"
#include "quaternion.h"

using namespace rove;

// Vectors
vec3 position(1.0f, 2.0f, 3.0f);
vec3 direction(0.0f, 1.0f, 0.0f);
direction.normalize();

// Dot and cross products
float dot = dot_product(position, direction);
vec3 cross;
cross_product(cross, position, direction);

// Matrices
matrix<4, 4, float> transform;
transform.identity();
transform.translate(1.0f, 2.0f, 3.0f);
transform.rotate(vec3(0.0f, 1.0f, 0.0f), PI / 4.0f);

// Quaternions
quaternion<float> q1, q2;
q1.identity();
q2 = quaternion<float>(0.0f, 0.707f, 0.0f, 0.707f);

// SLERP interpolation
quaternion_slerper<float> slerper;
slerper.setup(q1, q2);
auto q_mid = slerper.interpolate(0.5f);

// Collision detection
sphere<3, float> s1(vec3(0, 0, 0), 1.0f);
sphere<3, float> s2(vec3(1.5f, 0, 0), 1.0f);
contact_info<3, float> contact;
bool colliding = collide(contact, s1, s2);
```

## Python Usage

```python
import pyrove
import numpy as np

# Vectors
v1 = pyrove.vec3(1.0, 2.0, 3.0)
v2 = pyrove.vec3(4.0, 5.0, 6.0)

# Vector operations
dot = pyrove.dot(v1, v2)
cross = pyrove.cross(v1, v2)
normalized = pyrove.normalize(v1)

# Matrices
m = pyrove.mat4()
m.identity()
m.translate(1.0, 2.0, 3.0)
m.rotate(pyrove.vec3(0.0, 1.0, 0.0), 3.14159 / 4.0)

# Transform vectors
v_transformed = m * v1

# Quaternions
q = pyrove.quat(0.0, 0.0, 0.0, 1.0)
q.normalize()

# SLERP
q1 = pyrove.quat(0.0, 0.0, 0.0, 1.0)
q2 = pyrove.quat(0.0, 0.707, 0.0, 0.707)
q_mid = pyrove.slerp(q1, q2, 0.5)

# NumPy integration
arr = np.array([1.0, 2.0, 3.0], dtype=np.float32)
v = pyrove.vec3.from_numpy(arr)
arr_back = v.to_numpy()

# Matrix from NumPy
mat_array = np.eye(4, dtype=np.float32)
mat = pyrove.mat4.from_numpy(mat_array)
mat_back = mat.to_numpy()

# Double precision types
dv = pyrove.dvec3(1.0, 2.0, 3.0)
dm = pyrove.dmat4()
dq = pyrove.dquat(0.0, 0.0, 0.0, 1.0)

# Geometric primitives

# Rays for ray casting
ray = pyrove.ray3(pyrove.vec3(0, 0, 0), pyrove.vec3(1, 0, 0))
point_on_ray = ray.apply(5.0)  # Get point at t=5

# Line segments
line = pyrove.line3(pyrove.vec3(0, 0, 0), pyrove.vec3(10, 0, 0))
distance = line.distance(pyrove.vec3(5, 3, 0))

# Planes with intersection tests
plane = pyrove.plane(pyrove.vec3(0, 0, 0), pyrove.vec3(0, 1, 0))
if plane.test_intersection(ray):
    t = plane.trace(ray)
    hit_point = ray.apply(t)

# Triangles with extensive geometric properties
tri = pyrove.triangle3(
    pyrove.vec3(0, 0, 0),
    pyrove.vec3(1, 0, 0),
    pyrove.vec3(0, 1, 0)
)
area = tri.area()
centroid = tri.cog()
circumcenter = tri.circumcenter()
if tri.trace(ray, 0.0, 100.0):
    print("Ray hits triangle!")

# Capsules for collision detection
capsule = pyrove.capsule3(
    pyrove.vec3(0, 0, 0),
    pyrove.vec3(0, 2, 0),
    0.5
)
if capsule.contains(pyrove.vec3(0, 1, 0.3)):
    print("Point inside capsule")

# Frustum culling
frustum = pyrove.frustum(view_projection_matrix)
bbox = pyrove.aabb3(pyrove.vec3(-1, -1, -1), pyrove.vec3(1, 1, 1))
if frustum.test_intersection(bbox):
    print("Object is visible")
```

## Running Python Tests

```bash
# From the build directory
python3 ../src/test_pyrove.py
```

## Architecture

All code lives in `src/` under the `rove` namespace.

### Conventions
- Templates use `scalar_t` typedef for the numeric type
- N-dimensional templates use `ARITY` constant
- Vectors use packed structs with unions for flexible component access
- Matrices use column-major storage (OpenGL style)
- Collision functions return bool and populate output parameters by reference

## Documentation

The library includes comprehensive Doxygen documentation in the header files.

### Generating Documentation

**Install Doxygen:**
```bash
sudo apt install doxygen graphviz
```

**Generate HTML documentation:**
```bash
./generate_docs.sh
```

Or manually:
```bash
doxygen Doxyfile
```

**View the documentation:**
```bash
xdg-open docs/html/index.html
```

The generated documentation includes:
- Detailed API reference for all classes and functions
- Class hierarchy and collaboration diagrams
- Mathematical explanations for transformations
- Usage examples and parameter descriptions

### Python Documentation

Comprehensive Sphinx documentation for the Python bindings.

**Install Sphinx:**
```bash
pip install -r docs/python/requirements.txt
```

**Build documentation:**
```bash
cd docs/python
make html
```

**View documentation:**
```bash
xdg-open docs/python/_build/html/index.html
```

The Python documentation includes:
- Getting started guide and tutorials
- Complete API reference for all classes
- NumPy integration examples
- Performance optimization tips
- Practical usage examples

## API Reference

### Vector Operations
- `length()`, `length_sq()` - Vector magnitude
- `normalize()` - Normalize in place
- `dot_product()` - Dot product
- `cross_product()` - Cross product (3D only)
- `is_collinear()` - Check if vectors are collinear

### Matrix Operations
- `identity()`, `zero()` - Initialize matrices
- `translation()`, `translate()` - Translation transforms
- `rotation()`, `rotate()` - Rotation transforms
- `scaling()`, `scale()` - Scaling transforms
- `perspective()` - Perspective projection
- `lookat()` - Camera view matrix
- `inverse()`, `transpose()` - Matrix operations
- `determinant()`, `trace()` - Matrix properties

### Quaternion Operations
- `identity()` - Set to identity quaternion
- `norm()`, `normalize()` - Quaternion normalization
- `dot_product()` - Quaternion dot product
- SLERP interpolation via `quaternion_slerper`

## Type Aliases

### C++
```cpp
using vec2 = vec<2, float>;
using vec3 = vec<3, float>;
using vec4 = vec<4, float>;
using mat3 = matrix<3, 3, float>;
using mat4 = matrix<4, 4, float>;
using quat = quaternion<float>;
```

### Python
- **Vectors**: `vec2`, `vec3`, `vec4` (float), `dvec2`, `dvec3`, `dvec4` (double)
- **Matrices**: `mat3`, `mat4` (float), `dmat3`, `dmat4` (double)
- **Quaternions**: `quat` (float), `dquat` (double)
- **Rays**: `ray2`, `ray3` (float), `ray2d`, `ray3d` (double)
- **Lines**: `line2`, `line3` (float), `line2d`, `line3d` (double)
- **Planes**: `plane` (float), `planed` (double)
- **Triangles**: `triangle3` (float), `triangle3d` (double)
- **Capsules**: `capsule2`, `capsule3` (float), `capsule2d`, `capsule3d` (double)
- **Spheres**: `sphere2`, `sphere3` (float), `sphere2d`, `sphere3d` (double)
- **AABB**: `aabb2`, `aabb3` (float), `aabb2d`, `aabb3d` (double)
- **OBB**: `obb2`, `obb3` (float), `obb2d`, `obb3d` (double)
- **Frustums**: `frustum` (float), `frustumd` (double)

## License

See LICENSE.md file for details.

## Contributing

Contributions are welcome! Please ensure all tests pass before submitting pull requests.

```bash
# Run C++ tests
cd build
ctest

# Run Python tests
cd build
cmake -DROVE_BUILD_PYTHON=ON ..
make
python3 ../src/test_pyrove.py
```
